# Stage 0: Minimal Hex Loader - Linux i386 ELF
# TRUE TRUST ANCHOR - Every byte documented. No compiler needed.
#
# Build: xxd -r -p stage0.hex > stage0 && chmod +x stage0
# Test:  echo "b8 01 00 00 00 bb 2a 00 00 00 cd 80" | ./stage0; echo $?
#        (exits with code 42)
#
# Size: < 200 bytes
#
# Registers: edi=buffer base, esi=write ptr, stack=read buffer
#
# ============================================================================
# ELF32 HEADER (52 bytes)
# ============================================================================
7f 45 4c 46                 # e_ident: ELF magic
01                          # EI_CLASS: 32-bit
01                          # EI_DATA: little-endian
01                          # EI_VERSION: 1
00                          # EI_OSABI: SYSV
00 00 00 00 00 00 00 00     # padding
02 00                       # e_type: ET_EXEC
03 00                       # e_machine: i386
01 00 00 00                 # e_version: 1
54 80 04 08                 # e_entry: 0x08048054
34 00 00 00                 # e_phoff: 52
00 00 00 00                 # e_shoff: 0
00 00 00 00                 # e_flags: 0
34 00                       # e_ehsize: 52
20 00                       # e_phentsize: 32
01 00                       # e_phnum: 1
00 00                       # e_shentsize: 0
00 00                       # e_shnum: 0
00 00                       # e_shstrndx: 0

# ============================================================================
# PROGRAM HEADER (32 bytes @ 0x34)
# ============================================================================
01 00 00 00                 # p_type: PT_LOAD
00 00 00 00                 # p_offset: 0
00 80 04 08                 # p_vaddr: 0x08048000
00 80 04 08                 # p_paddr: 0x08048000
00 01 00 00                 # p_filesz: 256
00 01 01 00                 # p_memsz: 0x10100 (code + 64K)
07 00 00 00                 # p_flags: RWX
00 10 00 00                 # p_align: 0x1000

# ============================================================================
# CODE @ 0x54 (84 bytes at entry 0x08048054)
# Registers: edi=buffer base, esi=write ptr
# ============================================================================

# mmap2(0, 0x10000, RWX, MAP_PRIVATE|MAP_ANON, -1, 0)
31 db                       # xor ebx, ebx (addr=0)
b9 00 00 01 00              # mov ecx, 0x10000 (64K)
ba 07 00 00 00              # mov edx, 7 (prot=RWX)
31 f6                       # xor esi, esi
be 22 00 00 00              # mov esi, 0x22 (MAP_PRIVATE|MAP_ANON)
83 cf ff                    # or edi, -1 (fd=-1)
31 ed                       # xor ebp, ebp (offset=0)
b8 c0 00 00 00              # mov eax, 192 (sys_mmap2)
cd 80                       # int 0x80
89 c7                       # mov edi, eax (buffer base)
89 c6                       # mov esi, eax (write ptr)

# read_loop @ 0x76:
50                          # push eax (make space on stack)
89 e1                       # mov ecx, esp (read buffer)
31 db                       # xor ebx, ebx (fd=stdin)
b2 01                       # mov dl, 1 (count)
b0 03                       # mov al, 3 (sys_read)
cd 80                       # int 0x80
85 c0                       # test eax, eax
74 27                       # jz execute (if EOF)

8a 01                       # mov al, [ecx]
58                          # pop eax (cleanup stack)

# skip whitespace
3c 20                       # cmp al, ' '
74 e9                       # je read_loop
3c 0a                       # cmp al, '\n'
74 e5                       # je read_loop
3c 09                       # cmp al, '\t'
74 e1                       # je read_loop

# first hex digit -> high nibble
e8 14 00 00 00              # call hex
c0 e0 04                    # shl al, 4
88 c2                       # mov dl, al (save high nibble)

# read second digit
50                          # push eax
89 e1                       # mov ecx, esp
31 db                       # xor ebx, ebx
b0 03                       # mov al, 3
cd 80                       # int 0x80
8a 01                       # mov al, [ecx]
58                          # pop eax
e8 02 00 00 00              # call hex
08 d0                       # or al, dl
88 06                       # mov [esi], al
46                          # inc esi
eb c7                       # jmp read_loop

# execute: pop and jump to buffer
58                          # pop eax
ff e7                       # jmp edi

# hex: convert ASCII hex digit to nibble (al -> al)
3c 39                       # cmp al, '9'
7e 04                       # jle numeric
24 df                       # and al, 0xdf (uppercase)
2c 37                       # sub al, 0x37 ('A'-10)
c3                          # ret
2c 30                       # numeric: sub al, '0'
c3                          # ret
