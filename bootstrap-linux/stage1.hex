# Stage 1: Minimal Hex-to-Binary - Linux i386 ELF
# Converts hex pairs to binary. Whitespace is ignored.
# NO comment handling - strip comments before piping.
#
# Build: grep -v '^\s*#' stage1.hex | sed 's/#.*//' | tr -d ' \n\t' | xxd -r -p > hex2bin
# Use:   grep -v '^\s*#' input.hex | sed 's/#.*//' | tr -d ' \n\t' | ./hex2bin > output
# ============================================================================

# ELF Header (52 bytes)
7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
02 00 03 00 01 00 00 00 54 80 04 08 34 00 00 00
00 00 00 00 00 00 00 00 34 00 20 00 01 00 00 00
00 00 00 00

# Program Header (32 bytes)
01 00 00 00 00 00 00 00 00 80 04 08 00 80 04 08
60 00 00 00 00 10 00 00 07 00 00 00 00 10 00 00

# Code at 0x54 (12 bytes)
# Super minimal: read pairs, convert, write, loop
# Uses: eax=syscall, ebx=fd, ecx=buf, edx=count

31 db                       # xor ebx, ebx (stdin/stdout=0/1)
eb 17                       # jmp _read

# _convert: al has hex char, convert to nibble
3c 39                       # cmp al, '9'
7e 02                       # jle _digit
2c 07                       # sub al, 7
2c 30                       # sub al, '0'
c3                          # ret

# _read: read first hex char
b0 03                       # mov al, 3 (read)
31 c9                       # xor ecx, ecx
51                          # push ecx (buffer)
89 e1                       # mov ecx, esp
b2 01                       # mov dl, 1
cd 80                       # int 0x80
85 c0                       # test eax, eax
74 23                       # jz _exit
58                          # pop eax (char)

# skip whitespace
3c 20                       # cmp al, ' '
74 eb                       # je _read
3c 0a                       # cmp al, '\n'
74 e7                       # je _read
3c 09                       # cmp al, '\t'
74 e3                       # je _read

# got first nibble
e8 d5 ff ff ff              # call _convert
c0 e0 04                    # shl al, 4
50                          # push eax

# read second char
b0 03                       # mov al, 3
31 c9                       # xor ecx, ecx
51                          # push ecx
89 e1                       # mov ecx, esp
b2 01                       # mov dl, 1
cd 80                       # int 0x80
58                          # pop eax

# convert and combine
e8 c1 ff ff ff              # call _convert
5a                          # pop edx (high nibble)
08 d0                       # or al, dl

# write byte
50                          # push eax
b0 04                       # mov al, 4 (write)
b3 01                       # mov bl, 1 (stdout)
89 e1                       # mov ecx, esp
b2 01                       # mov dl, 1
cd 80                       # int 0x80
58                          # pop eax
31 db                       # xor ebx, ebx
eb b8                       # jmp _read

# _exit
b0 01                       # mov al, 1
cd 80                       # int 0x80
