# Stage 2: Mini Forth - Linux i386
# Build: cat stage2.hex | ./hex2bin > forth && chmod +x forth
#
# Commands: 0-9 + - * / > d x s @ ! H , q
# Size: ~350 bytes
# ============================================================================

# ebp = stack (down from 0x10000), edi = HERE, esi/ebx = number building

# === INIT ===
bd 00 00 01 00              # mov ebp, 0x10000
bf 00 20 00 00              # mov edi, 0x2000 (HERE)
31 f6                       # xor esi, esi
31 db                       # xor ebx, ebx

# === LOOP @0x0e ===
6a 00                       # push 0
b8 03 00 00 00              # mov eax, 3
31 c9                       # xor ecx, ecx
8d 4c 24 00                 # lea ecx, [esp]
ba 01 00 00 00              # mov edx, 1
cd 80                       # int 0x80
85 c0                       # test eax, eax
0f 84 20 01 00 00           # jz _quit
8a 04 24                    # mov al, [esp]
83 c4 04                    # add esp, 4

# Digit?
3c 30                       # cmp al, '0'
7c 13                       # jl _not_digit
3c 39                       # cmp al, '9'
7f 0f                       # jg _not_digit
2c 30                       # sub al, '0'
0f b6 c0                    # movzx eax, al
6b db 0a                    # imul ebx, 10
01 c3                       # add ebx, eax
be 01 00 00 00              # mov esi, 1
eb c3                       # jmp _loop

# _not_digit
85 f6                       # test esi, esi
74 08                       # jz _no_push
83 ed 04                    # sub ebp, 4
89 5d 00                    # mov [ebp], ebx
31 db                       # xor ebx, ebx
31 f6                       # xor esi, esi

# _no_push - whitespace?
3c 20                       # cmp al, ' '
74 b1                       # je _loop
3c 0a                       # cmp al, '\n'
74 ad                       # je _loop
3c 09                       # cmp al, '\t'
74 a9                       # je _loop

# Commands
3c 2b                       # +
75 0a                       # jne
8b 45 00                    # mov eax, [ebp]
83 c5 04                    # add ebp, 4
01 45 00                    # add [ebp], eax
eb 9b                       # jmp _loop

3c 2d                       # -
75 0a                       # jne
8b 45 00                    # mov eax, [ebp]
83 c5 04                    # add ebp, 4
29 45 00                    # sub [ebp], eax
eb 8d                       # jmp _loop

3c 2a                       # *
75 0d                       # jne
8b 45 04                    # mov eax, [ebp+4]
f7 6d 00                    # imul dword [ebp]
83 c5 04                    # add ebp, 4
89 45 00                    # mov [ebp], eax
eb 7c                       # jmp _loop

3c 2f                       # /
75 10                       # jne
8b 4d 00                    # mov ecx, [ebp]
8b 45 04                    # mov eax, [ebp+4]
99                          # cdq
f7 f9                       # idiv ecx
83 c5 04                    # add ebp, 4
89 45 00                    # mov [ebp], eax
eb 68                       # jmp _loop

3c 3e                       # > emit
75 14                       # jne
8b 45 00                    # mov eax, [ebp]
83 c5 04                    # add ebp, 4
50                          # push eax
b8 04 00 00 00              # mov eax, 4
bb 01 00 00 00              # mov ebx, 1
89 e1                       # mov ecx, esp
ba 01 00 00 00              # mov edx, 1
cd 80                       # int 0x80
58                          # pop eax
31 db                       # xor ebx, ebx (restore)
eb 48                       # jmp _loop

3c 64                       # d (dup)
75 0a                       # jne
8b 45 00                    # mov eax, [ebp]
83 ed 04                    # sub ebp, 4
89 45 00                    # mov [ebp], eax
eb 3a                       # jmp _loop

3c 78                       # x (drop)
75 04                       # jne
83 c5 04                    # add ebp, 4
eb 32                       # jmp _loop

3c 73                       # s (swap)
75 0c                       # jne
8b 45 00                    # mov eax, [ebp]
8b 55 04                    # mov edx, [ebp+4]
89 55 00                    # mov [ebp], edx
89 45 04                    # mov [ebp+4], eax
eb 22                       # jmp _loop

3c 40                       # @ (fetch)
75 06                       # jne
8b 45 00                    # mov eax, [ebp]
8b 00                       # mov eax, [eax]
89 45 00                    # mov [ebp], eax
eb 14                       # jmp _loop

3c 21                       # ! (store)
75 0a                       # jne
8b 45 00                    # mov eax, [ebp]
8b 55 04                    # mov edx, [ebp+4]
89 10                       # mov [eax], edx
83 c5 08                    # add ebp, 8
eb 04                       # jmp _loop

3c 48                       # H (HERE)
75 06                       # jne
83 ed 04                    # sub ebp, 4
89 7d 00                    # mov [ebp], edi
e9 3f ff ff ff              # jmp _loop (near)

3c 2c                       # , (comma - compile)
75 06                       # jne
8b 45 00                    # mov eax, [ebp]
83 c5 04                    # add ebp, 4
89 07                       # mov [edi], eax
83 c7 04                    # add edi, 4
e9 2c ff ff ff              # jmp _loop

3c 71                       # q (quit)
75 07                       # jne _unknown
# _quit
b8 01 00 00 00              # mov eax, 1
31 db                       # xor ebx, ebx
cd 80                       # int 0x80

# _unknown - ignore
e9 18 ff ff ff              # jmp _loop
